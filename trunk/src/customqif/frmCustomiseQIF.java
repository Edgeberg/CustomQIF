/*
 * frmCustomiseQIF.java
 * Created on 20 March 2007, 01:09
 */
package customqif;

import java.awt.Component;
import java.awt.FileDialog;
import java.awt.GraphicsConfiguration;
import java.awt.GraphicsDevice;
import java.awt.GraphicsEnvironment;
import java.awt.Rectangle;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.OutputStream;
import java.util.Properties;
import javax.swing.Box;
import javax.swing.JOptionPane;
import javax.swing.table.DefaultTableModel;
import org.netbeans.swing.etable.ETableColumnModel;
// import javax.swing.table.TableModel;

/**
 *
 * @author  Edgeberg <eldon_r@users.sf.net>
 */
public final class frmCustomiseQIF extends javax.swing.JFrame {

    double appVersion;
    int intGridColumns;      
    int intElements = 0;
    int intElement = 0;
    int intType = 0;
    String strHeader = "";
    String strTypes = "DTMNL";
    int D = strTypes.indexOf('D');
    int T = strTypes.indexOf('T');
    int M = strTypes.indexOf('M');
    int N = strTypes.indexOf('N');
    int L = strTypes.indexOf('L');
    // Columns in their internally represented order
    int colRow = 0;
    int colNarration = 1;
    int colXDate = 2;
    int colXAmount = 3;
    int colCheque = 4;
    int colXType = 5;
    int colAccount = 6;
    int colAnnotation = 7;
    
    String aryQIF[][] = null;
    Boolean aryKeep[] = null;
    String strNarrationPatterns = "";
    String aryNarrationPatterns[];
    String strPatternFile = "";
    DefaultTableModel tableModelInProgress;
    Boolean blnCancelModalDialog = false;
    Boolean blnSkipModalDialog = false;
    Boolean blnReversedTransactions = false;
    Boolean blnCaseSensitive = false;
    Boolean blnReformatDate = false;    // If we have sensed that we've got MM/DD/YYYY dates; we want YYYYMMDD.
    Boolean blnDDMM = false;            // If the above is true AND we've found an obvious DD/MM/YYYY formatted date in the file.
                                        // FIXME: This is a limited, inflexible check, and we currently only handle these 3 options.
    String strMatchErrorStr = "";   // Name of field that has a match (regular expression) error
    int intMatchErrorLine = -1;      // Line (starting at 0) within pattern list of matching error
    java.util.regex.PatternSyntaxException lastPE = null; // Pattern match error details
    
    /** Creates new form frmCustomiseQIF */
    public frmCustomiseQIF() {
        this.appVersion = 0.91;
        this.intGridColumns = 6;        // Just a default; we'll get it from the grid later
        initComponents();

        // Put Help menu on the RHS by inserting a HorizontalGlue component just before it
        mb.add(Box.createHorizontalGlue(), mb.getComponentIndex(mHelp));
        
        // Make the WindowListener our only way out of this app.:
        setDefaultCloseOperation(DO_NOTHING_ON_CLOSE);

        addWindowListener(new WindowAdapter() {

            @Override
            public void windowClosing(WindowEvent e) {
                doTheCloseThing();
            }
        });

        loadState();
        loadGrid();
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jpmTableContext = new javax.swing.JPopupMenu();
        jmiEdit = new javax.swing.JMenuItem();
        jMenu1 = new javax.swing.JMenu();
        jScrollPane1 = new javax.swing.JScrollPane();
        stringTable = new org.netbeans.swing.etable.ETable();
        btnExecute = new javax.swing.JButton();
        btnLearn = new javax.swing.JButton();
        btnInputFile = new javax.swing.JButton();
        ctlInputFile = new javax.swing.JTextField();
        btnOutputFile = new javax.swing.JButton();
        ctlOutputFile = new javax.swing.JTextField();
        mb = new javax.swing.JMenuBar();
        mFile = new javax.swing.JMenu();
        miOpen = new javax.swing.JMenuItem();
        miSave = new javax.swing.JMenuItem();
        miSaveAs = new javax.swing.JMenuItem();
        miQuit = new javax.swing.JMenuItem();
        mEdit = new javax.swing.JMenu();
        miAdd = new javax.swing.JMenuItem();
        miRemove = new javax.swing.JMenuItem();
        miEdit = new javax.swing.JMenuItem();
        miUp = new javax.swing.JMenuItem();
        miDown = new javax.swing.JMenuItem();
        mOptions = new javax.swing.JMenu();
        miNarrationOnly = new javax.swing.JMenuItem();
        miReversedTransactions = new javax.swing.JCheckBoxMenuItem();
        miCaseSensitive = new javax.swing.JCheckBoxMenuItem();
        mHelp = new javax.swing.JMenu();
        miAbout = new javax.swing.JMenuItem();

        jpmTableContext.setInvoker(stringTable);

        jmiEdit.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_E, java.awt.event.InputEvent.CTRL_DOWN_MASK));
        jmiEdit.setMnemonic('E');
        jmiEdit.setText("Edit");
        jmiEdit.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                miEditActionPerformed(evt);
            }
        });
        jpmTableContext.add(jmiEdit);

        jMenu1.setText("jMenu1");

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Customise QIF files downloaded from the bank");

        jScrollPane1.setPreferredSize(new java.awt.Dimension(600, 402));

        stringTable.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {
                "#", "Narration", "Date", "Amount", "ChequeNum", "Transaction Type Pattern", "Transaction Type Replacement", "Annotation"
            }
        ) {
            Class[] types = new Class [] {
                java.lang.Integer.class, java.lang.String.class, java.lang.String.class, java.lang.String.class, java.lang.String.class, java.lang.String.class, java.lang.String.class, java.lang.String.class
            };
            boolean[] canEdit = new boolean [] {
                false, true, true, true, true, true, true, true
            };

            public Class getColumnClass(int columnIndex) {
                return types [columnIndex];
            }

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        stringTable.setComponentPopupMenu(jpmTableContext);
        stringTable.setPopupUsedFromTheCorner(true);
        jScrollPane1.setViewportView(stringTable);
        if (stringTable.getColumnModel().getColumnCount() > 0) {
            stringTable.getColumnModel().getColumn(0).setMinWidth(35);
            stringTable.getColumnModel().getColumn(0).setPreferredWidth(35);
            stringTable.getColumnModel().getColumn(0).setMaxWidth(50);
            stringTable.getColumnModel().getColumn(1).setPreferredWidth(300);
            stringTable.getColumnModel().getColumn(7).setPreferredWidth(200);
        }

        btnExecute.setMnemonic('x');
        btnExecute.setText("Execute");
        btnExecute.setToolTipText("Do the operation");
        btnExecute.setMaximumSize(new java.awt.Dimension(75, 29));
        btnExecute.setMinimumSize(new java.awt.Dimension(75, 29));
        btnExecute.setPreferredSize(new java.awt.Dimension(75, 29));
        btnExecute.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnExecuteActionPerformed(evt);
            }
        });

        btnLearn.setMnemonic('N');
        btnLearn.setText("Learn");
        btnLearn.setMaximumSize(new java.awt.Dimension(75, 29));
        btnLearn.setMinimumSize(new java.awt.Dimension(75, 29));
        btnLearn.setPreferredSize(new java.awt.Dimension(75, 29));
        btnLearn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnLearnActionPerformed(evt);
            }
        });

        btnInputFile.setMnemonic('I');
        btnInputFile.setText("Input File");
        btnInputFile.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnInputFileActionPerformed(evt);
            }
        });

        btnOutputFile.setMnemonic('O');
        btnOutputFile.setText("Output File");
        btnOutputFile.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnOutputFileActionPerformed(evt);
            }
        });

        mFile.setMnemonic('F');
        mFile.setText("File");

        miOpen.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_O, java.awt.event.InputEvent.CTRL_DOWN_MASK));
        miOpen.setMnemonic('O');
        miOpen.setText("Open");
        miOpen.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                miOpenActionPerformed(evt);
            }
        });
        mFile.add(miOpen);

        miSave.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_S, java.awt.event.InputEvent.CTRL_DOWN_MASK));
        miSave.setMnemonic('S');
        miSave.setText("Save");
        miSave.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                miSaveActionPerformed(evt);
            }
        });
        mFile.add(miSave);

        miSaveAs.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_A, java.awt.event.InputEvent.SHIFT_DOWN_MASK | java.awt.event.InputEvent.CTRL_DOWN_MASK));
        miSaveAs.setMnemonic('A');
        miSaveAs.setText("Save As...");
        miSaveAs.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                miSaveAsActionPerformed(evt);
            }
        });
        mFile.add(miSaveAs);

        miQuit.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_Q, java.awt.event.InputEvent.CTRL_DOWN_MASK));
        miQuit.setMnemonic('Q');
        miQuit.setText("Quit");
        miQuit.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                miQuitActionPerformed(evt);
            }
        });
        mFile.add(miQuit);

        mb.add(mFile);

        mEdit.setMnemonic('E');
        mEdit.setText("Edit");
        mEdit.setToolTipText("");

        miAdd.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_INSERT, 0));
        miAdd.setMnemonic('A');
        miAdd.setText("Add");
        miAdd.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                miAddActionPerformed(evt);
            }
        });
        mEdit.add(miAdd);

        miRemove.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_DELETE, 0));
        miRemove.setMnemonic('R');
        miRemove.setText("Remove");
        miRemove.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                miRemoveActionPerformed(evt);
            }
        });
        mEdit.add(miRemove);

        miEdit.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_E, java.awt.event.InputEvent.CTRL_DOWN_MASK));
        miEdit.setMnemonic('E');
        miEdit.setText("Edit");
        miEdit.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                miEditActionPerformed(evt);
            }
        });
        mEdit.add(miEdit);

        miUp.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_UP, java.awt.event.InputEvent.ALT_DOWN_MASK));
        miUp.setMnemonic('U');
        miUp.setText("Move Up");
        miUp.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                miUpActionPerformed(evt);
            }
        });
        mEdit.add(miUp);

        miDown.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_DOWN, java.awt.event.InputEvent.ALT_DOWN_MASK));
        miDown.setMnemonic('D');
        miDown.setText("Move Down");
        miDown.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                miDownActionPerformed(evt);
            }
        });
        mEdit.add(miDown);

        mb.add(mEdit);

        mOptions.setMnemonic('O');
        mOptions.setText("Options");

        miNarrationOnly.setText("Narration Only transactions to avoid combining");
        miNarrationOnly.setToolTipText("Configure a list of patterns that represent narrations that stand by themselves");
        miNarrationOnly.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                miNarrationOnlyActionPerformed(evt);
            }
        });
        mOptions.add(miNarrationOnly);

        miReversedTransactions.setText("Transactions in Reversed Date Order");
        mOptions.add(miReversedTransactions);

        miCaseSensitive.setText("Case-Sensitive Comparisons");
        miCaseSensitive.setToolTipText("With this unchecked you don't have to cover both upper and lower case variations for a pattern");
        mOptions.add(miCaseSensitive);

        mb.add(mOptions);

        mHelp.setMnemonic('H');
        mHelp.setText("Help");
        mHelp.setInheritsPopupMenu(true);

        miAbout.setMnemonic('A');
        miAbout.setText("About");
        miAbout.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                miAboutActionPerformed(evt);
            }
        });
        mHelp.add(miAbout);

        mb.add(mHelp);

        setJMenuBar(mb);

        org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(layout.createSequentialGroup()
                .addContainerGap()
                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                    .add(layout.createSequentialGroup()
                        .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.TRAILING, false)
                            .add(btnOutputFile, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .add(btnInputFile, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                        .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.TRAILING)
                            .add(layout.createSequentialGroup()
                                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                                    .add(ctlInputFile, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 498, Short.MAX_VALUE)
                                    .add(ctlOutputFile))
                                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                                .add(btnLearn, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 110, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                            .add(layout.createSequentialGroup()
                                .add(0, 0, Short.MAX_VALUE)
                                .add(btnExecute, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 110, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))))
                    .add(jScrollPane1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 733, Short.MAX_VALUE))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(layout.createSequentialGroup()
                .add(jScrollPane1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 240, Short.MAX_VALUE)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                    .add(btnInputFile)
                    .add(ctlInputFile, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                    .add(btnExecute, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                    .add(btnOutputFile)
                    .add(ctlOutputFile, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                    .add(btnLearn, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                .addContainerGap())
        );

        getAccessibleContext().setAccessibleName("Customise QIF");
        getAccessibleContext().setAccessibleDescription("Customise QIF files downloaded from the bank");

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void btnOutputFileActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnOutputFileActionPerformed
        openFile(evt.getActionCommand());
    }//GEN-LAST:event_btnOutputFileActionPerformed

    private void btnInputFileActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnInputFileActionPerformed
        openFile(evt.getActionCommand());
    }//GEN-LAST:event_btnInputFileActionPerformed

    private void btnLearnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnLearnActionPerformed
        doTranslation(true);
    }//GEN-LAST:event_btnLearnActionPerformed

    private void miOpenActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_miOpenActionPerformed
        frmLoadSave fls;
        fls = new frmLoadSave(this, false, System.getProperty("user.home") + System.getProperty("file.separator") + ".CustomQIF");
        fls.setVisible(true);
    }//GEN-LAST:event_miOpenActionPerformed

    private void btnExecuteActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnExecuteActionPerformed
        doTranslation(false);
    }//GEN-LAST:event_btnExecuteActionPerformed

    private void miSaveActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_miSaveActionPerformed
        saveGrid();
    }//GEN-LAST:event_miSaveActionPerformed

    private void miQuitActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_miQuitActionPerformed
        doTheCloseThing();
    }//GEN-LAST:event_miQuitActionPerformed

    private void miRemoveActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_miRemoveActionPerformed
        if ((stringTable.getRowCount() > 1)
                && (stringTable.getSelectedRowCount() > 0)) {
            DefaultTableModel tableModel = (DefaultTableModel) stringTable.getModel();
            for (int i=stringTable.getRowCount() + 1; i>0 ; i--) {
                if (stringTable.isRowSelected(i)) {
                    tableModel.removeRow(i);
                }
            }
            stringTable.setModel(tableModel);
            numberGrid();
        }
    }//GEN-LAST:event_miRemoveActionPerformed

    private void miNarrationOnlyActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_miNarrationOnlyActionPerformed
        new frmNarrationOnly(this, strNarrationPatterns).setVisible(true);
    }//GEN-LAST:event_miNarrationOnlyActionPerformed

    /**
     * Event handler for the "File \ Save As" menu item
     * @param evt The event that caused the action to be performed
     */
    private void miSaveAsActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_miSaveAsActionPerformed
        frmLoadSave fls = new frmLoadSave(this, true, System.getProperty("user.home") + System.getProperty("file.separator") + ".CustomQIF");
        fls.setVisible(true);
    }//GEN-LAST:event_miSaveAsActionPerformed

    private void miUpActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_miUpActionPerformed
        if (stringTable.getSelectedRowCount() > 0 && ! stringTable.isRowSelected(0)) {
            int iRow = stringTable.getSelectedRow();
            DefaultTableModel tableModel = (DefaultTableModel) stringTable.getModel();
            for (int i=1 ; i<stringTable.getRowCount() ; i++) {
                if (stringTable.isRowSelected(i)) {
                    tableModel.moveRow(i, i, i - 1);
                }
            }
            stringTable.setModel(tableModel);
            stringTable.changeSelection(iRow - 1, stringTable.getSelectedColumn(), false, false);
            numberGrid();
        }
    }//GEN-LAST:event_miUpActionPerformed

    private void miDownActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_miDownActionPerformed
        if (stringTable.getSelectedRowCount() > 0 && ! stringTable.isRowSelected(stringTable.getRowCount() - 1)) {
            int iRow = stringTable.getSelectedRow();
            DefaultTableModel tableModel = (DefaultTableModel) stringTable.getModel();
            for (int i=stringTable.getRowCount() - 2 ; i>0 ; i--) {
                if (stringTable.isRowSelected(i)) {
                    tableModel.moveRow(i, i, i + 1);
                }
            }
            stringTable.setModel(tableModel);
            stringTable.changeSelection(iRow + 1, stringTable.getSelectedColumn(), false, false);
            numberGrid();
        }
    }//GEN-LAST:event_miDownActionPerformed

    private void miEditActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_miEditActionPerformed
        if ((stringTable.getRowCount() > 1)
                && (stringTable.getSelectedRowCount() == 1)) {
            dlgEdit de = new dlgEdit(this, true,
                "",
                stringTable.getValueAt(stringTable.getSelectedRow(),colNarration).toString(),
                stringTable.getValueAt(stringTable.getSelectedRow(),colXDate).toString(),
                stringTable.getValueAt(stringTable.getSelectedRow(),colXAmount).toString(),
                stringTable.getValueAt(stringTable.getSelectedRow(),colCheque).toString(),
                stringTable.getValueAt(stringTable.getSelectedRow(),colXType).toString(),
                stringTable.getValueAt(stringTable.getSelectedRow(),colAccount).toString(),
                stringTable.getValueAt(stringTable.getSelectedRow(),colAnnotation).toString(),
                getAccountList(),
                stringTable.getSelectedRow());

            // See if dlgEdit can fit on the screen at our preferred location
            Rectangle rect = getThisScreen(this.getX(), this.getY());
            if (rect != null) {
                int xmax = rect.width + rect.x, ymax = rect.height + rect.y;
                int x = getX() + 100, y = getY() + 100;
                // If dlgEdit would overlap the screen edge in X or Y direction, adjust proposed position to prevent:
                if (x + de.getWidth() > xmax) x = xmax - de.getWidth();
                if (y + de.getHeight() > ymax) y = ymax - de.getHeight();
                de.setLocation(x, y);
            }
            de.setVisible(true);
        }
    }//GEN-LAST:event_miEditActionPerformed

    private void miAddActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_miAddActionPerformed
        DefaultTableModel tableModel = (DefaultTableModel) stringTable.getModel();
        int r = stringTable.getRowCount() - 1;
        if (stringTable.getSelectedRowCount() == 0 || stringTable.getSelectedRow() == stringTable.getRowCount() - 1) {
            tableModel.addRow((Object[]) null);
        } else {
            tableModel.insertRow(stringTable.getSelectedRow() + 1, (Object[]) null);
            r = stringTable.getSelectedRow();
        }
        stringTable.setModel(tableModel);
        stringTable.changeSelection(r + 1, 0, false, false);
        numberGrid();
    }//GEN-LAST:event_miAddActionPerformed

    private void miAboutActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_miAboutActionPerformed
        JOptionPane.showMessageDialog(this, Main.AppName.concat(" version ").concat(Main.AppVersion).concat("\n\n").concat(Main.AppURL), "About", JOptionPane.INFORMATION_MESSAGE);
    }//GEN-LAST:event_miAboutActionPerformed

    /**
     * The main member, which receives initial program control
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        java.awt.EventQueue.invokeLater(new Runnable() {

            @Override
            public void run() {
                new frmCustomiseQIF().setVisible(true);
            }
        });
    }

    /**
     * Function to eliminate nulls (changes a null to an empty string, otherwise returns the input string)
     * @param strString
     * @return a String, which will be "" if strString is null, otherwise = strString
     */
    public String nvl(String strString) {
        if (strString == null) {
            return "";
        } else {
            return strString;
        }
    }

    private String nnvl(String strStringToCompare, String strStringToReturnIfNotNull) {
        if (strStringToCompare == null) {
            return "";
        } else {
            return strStringToReturnIfNotNull;
        }
    }

    /**
     * Show a dialog box indicating a given error condition
     * @param window The parent window of the dialog box
     * @param errorText What error text to show
     * @param dialogTitle The dialog box title text
     */
    public void handleException(Component window, String errorText, String dialogTitle) {
        //if (getOption("HitAuthor", false).equals("Yes")) {
        //    System.err.println("Author email not implemented...");
        //}
        //if (getOption("ErrorsToStdout", false).equalsIgnoreCase("Yes")) {
        System.out.print(dialogTitle + ": " + errorText);
        //}
        JOptionPane.showMessageDialog(window, errorText, dialogTitle, JOptionPane.ERROR_MESSAGE);
    }

    /**
     * Split the tab-delimited string strNarrationPatterns into the string array aryNarrationPatterns
     */
    public void tabStrToArray() {
        if (!strNarrationPatterns.trim().equals("")) {
            aryNarrationPatterns = strNarrationPatterns.split("\t");
        } else {
            aryNarrationPatterns = null;
        }
    }

    public boolean safeMatchString(String strString, String strPattern, String strStringName, int intPatternListLine, boolean blnCanErrorDlg) {
        boolean res = false;
        try {
            if (blnCaseSensitive) {
                res = nvl(strString).matches(strPattern);
            } else {
                res = nvl(strString).toUpperCase().matches(strPattern.toUpperCase());
            }
        } catch (java.util.regex.PatternSyntaxException pe) {
            if (blnCanErrorDlg) {
                // We're allowed to tell the user immediately
                JOptionPane.showMessageDialog(this, strStringName + " ('" + strPattern + "') has an error in its pattern syntax.\n" + "Error is: '" + pe.getDescription() + "'", "ERROR", JOptionPane.ERROR_MESSAGE);
            } else {
                // Just remember for later
                lastPE = pe;
                intMatchErrorLine = ++intPatternListLine;
                strMatchErrorStr = strStringName;
            }
        }
        return res;
    }
    
    public boolean matchTransaction(String strSearchDesc, String strSearchDate, String strSearchAmount, String strSearchCheque, String strTypeCode,
            String strNarration, String strType, String strDate, String strAmount, String strCheque,
            int intPatternListLine,
            boolean blnCanErrorDlg) {
        boolean blnMatchesNarration = safeMatchString(strNarration, strSearchDesc, "Narration", intPatternListLine, blnCanErrorDlg);
        boolean blnMatchesDate = (strSearchDate.isEmpty() || safeMatchString(strDate, strSearchDate, "Date", intPatternListLine, blnCanErrorDlg));
        boolean blnMatchesAmount = (strSearchAmount.isEmpty() || safeMatchString(strAmount, strSearchAmount, "Amount", intPatternListLine, blnCanErrorDlg));
        boolean blnMatchesCheque = (strSearchCheque.isEmpty() || safeMatchString(strCheque, strSearchCheque, "Cheque", intPatternListLine, blnCanErrorDlg));
        boolean blnMatchesType = (strTypeCode.isEmpty() || safeMatchString(strType, strTypeCode, "Type", intPatternListLine, blnCanErrorDlg));
        boolean blnMatch = blnMatchesNarration
                && blnMatchesDate
                && blnMatchesAmount
                && blnMatchesCheque
                && blnMatchesType;
        return blnMatch;
    }
    
    private void doTranslation(boolean learn) {
        boolean blnCancel = false;
        boolean blnMatch;
        String strSearchDesc;
        String strSearchDate;
        String strSearchCheque;
        String strSearchAmount;
        String strTypeCode;
        String strReplaceTypeWith;
        String strInputFile;
        Rectangle rect;

        strInputFile = combineNarrations();
        if (strInputFile == null) {
            return;
        }

        int i;
        int e = 0;
        tableModelInProgress = (DefaultTableModel) stringTable.getModel();
        int rows = tableModelInProgress.getRowCount();

        lastPE = null;
        intMatchErrorLine = -1;

        blnCaseSensitive = miCaseSensitive.getState();
        
        //status1.setText("Processing...");
        BufferedWriter out = null;
        try {
            if (!learn) {
                // Open output file, write header line
                out = new BufferedWriter(new FileWriter(ctlOutputFile.getText()));
                if (strHeader != null) {
                    out.write(strHeader + "\n");
                }
            }
            try {
                while ((e < intElements) && !blnCancel) {
                    if (aryQIF[e][M] != null && aryKeep[e]) {
                        blnMatch = false;
                        for (i = 0; (!blnMatch) && (i < rows); i++) {
                            strSearchDesc = tableModelInProgress.getValueAt(i, colNarration).toString();
                            strSearchDate = tableModelInProgress.getValueAt(i, colXDate).toString();
                            strSearchAmount = tableModelInProgress.getValueAt(i, colXAmount).toString();
                            strSearchCheque = tableModelInProgress.getValueAt(i, colCheque).toString();
                            strTypeCode = tableModelInProgress.getValueAt(i, colXType).toString();
                            strReplaceTypeWith = tableModelInProgress.getValueAt(i, colAccount).toString();
                            if (matchTransaction(strSearchDesc, strSearchDate, strSearchAmount, strSearchCheque, strTypeCode, aryQIF[e][M], aryQIF[e][L], aryQIF[e][D], aryQIF[e][T], aryQIF[e][N], i, false)) {
                                blnMatch = true;
                                aryQIF[e][L] = strReplaceTypeWith;
                                if (!tableModelInProgress.getValueAt(i, colAnnotation).toString().equals("")) {
                                    aryQIF[e][M] = aryQIF[e][M].concat(" - ").concat(tableModelInProgress.getValueAt(i, colAnnotation).toString());
                                }
                                //JOptionPane.showMessageDialog(this, "'" + strLine + "' matches '" + strSearchDesc + "'", "Eureka!", JOptionPane.INFORMATION_MESSAGE);
                            }
                        }
                        if (!blnMatch) {
                            if (learn) {
                                blnSkipModalDialog = false;
                                dlgEdit de = new dlgEdit(this, true,
                                          nvl(aryQIF[e][M]) + nnvl(aryQIF[e][M], "\n")
                                        + nvl(aryQIF[e][L]) + nnvl(aryQIF[e][L], "\n")
                                        + nvl(aryQIF[e][D]) + nnvl(aryQIF[e][D], "\n")
                                        + nvl(aryQIF[e][T]) + nnvl(aryQIF[e][T], "\n")
                                        + nvl(aryQIF[e][N]) + nnvl(aryQIF[e][N], ""),
                                    aryQIF[e][M],
                                    "",
                                    "",
                                    "",
                                    aryQIF[e][L],
                                    aryQIF[e][L],
                                    "",
                                    getAccountList(),
                                    -1);
                                // See if dlgEdit can fit on the screen at our preferred location
                                rect = getThisScreen(this.getX(), this.getY());
                                if (rect != null) {
                                    int xmax = rect.width + rect.x, ymax = rect.height + rect.y;
                                    int x = getX() + jScrollPane1.getWidth() + 22;
                                    int y = getY() + btnLearn.getY() + mb.getHeight() + btnLearn.getHeight() + 35;
                                    // If dlgEdit would overlap the screen edge in X or Y direction, adjust proposed position to prevent:
                                    if (x + de.getWidth() > xmax) x = xmax - de.getWidth();
                                    if (y + de.getHeight() > ymax) y = ymax - de.getHeight();
                                    de.setLocation(x, y);
                                }
                                de.setVisible(true);
                                blnCancel = blnCancelModalDialog;
                                if (!blnCancel && !blnSkipModalDialog) {
                                    rows++;
                                    aryQIF[e][L] = tableModelInProgress.getValueAt(rows - 1, colAccount).toString();
                                }
                            }
                        }
                    }
                    if (!learn && aryKeep[e]) {
                        if (aryQIF[e][L] != null) {
                            out.write("L" + aryQIF[e][L] + "\n");
                        }
                        if (aryQIF[e][D] != null) {
                            out.write("D" + aryQIF[e][D] + "\n");
                        }
                        if (aryQIF[e][M] != null) {
                            out.write("M" + aryQIF[e][M] + "\n");
                        }
                        if (aryQIF[e][N] != null) {
                            out.write("N" + aryQIF[e][N] + "\n");
                        }
                        if (aryQIF[e][T] != null) {
                            out.write("T" + aryQIF[e][T] + "\n");
                        }
                        out.write("^\n");
                    }
                    e++;
                }
                //in.close();
            } catch (IOException exTransWrite) {
                handleException(this, "Error while writing " + ctlOutputFile.getText() + ": " + exTransWrite.toString(), "btnExecuteActionPerformed subroutine");
            }
            if (!learn) {
                out.close();
            }
        } catch (IOException exTransWrite2) {
            handleException(this, "Error while writing " + ctlOutputFile.getText() + ": " + exTransWrite2.toString(), "btnExecuteActionPerformed subroutine part 2");
        }
        if (lastPE != null) {
            JOptionPane.showMessageDialog(this, "The last Pattern Syntax error encountered was '"
                    + lastPE.getDescription() + "',\nfor the pattern '" + lastPE.getPattern()
                    + "'\n in the field '" + strMatchErrorStr + "' (pattern list line " + intMatchErrorLine + ").\n\nDetails follow:\n\n"
                    + lastPE.getMessage(), "Pattern Error(s) Detected", JOptionPane.ERROR_MESSAGE);
        }
    }

    /**
     * Load the working grid from the specified data file
     */
    public void loadGrid() {
        int r, i;
        int intFileColumns = 1;
        String strLine;
        String[] ary, ary0;
        String strTabs = "";

        // Build a list of tab characters to append to input lines to ensure split() works as desired.
        intGridColumns = stringTable.getColumnCount();
        for (i=1; i<intGridColumns; i++) {
            strTabs += '\t';
        }

        // First see if the .CustomQIF directory exists and create it if not
        File myProgramDir = new File(System.getProperty("user.home") + System.getProperty("file.separator") + ".CustomQIF");
        if (!myProgramDir.mkdirs()) {
            File myStartupFile = new File(myProgramDir, strPatternFile + ".Patterns");
            if (myStartupFile.exists()) {
                // Get a copy of the table structure
                DefaultTableModel tableModel = (DefaultTableModel) stringTable.getModel();
                // Clear table first
                tableModel.setRowCount(0);
                try {
                    BufferedReader in = new BufferedReader(new FileReader(myStartupFile));
                    r = 1;
                    while ((strLine = in.readLine()) != null) {
                        if (r == 1) {
                            // Assuming that sampling row 1 is sufficient to determine if this is an old file structure,
                            // Count the number of columns (= number of tabs + 1)
                            for (i=0; i<strLine.length(); i++) {
                                if (strLine.charAt(i) == '\t') intFileColumns++;
                            }
                        }
                        ary = strLine.concat(strTabs).split("\t", intGridColumns);    // Making sure we at least get intGridColumns tab-delimited elements
                        if ((intFileColumns == 4) && (intGridColumns == 8)) {
                            // Migrate from pre-0.91 file (4 tab-separated columns) to 0.91 file (7 tab-separated columns)
                            // (The 8 above includes the row number column which is not saved in the file)
                            // First, shift column data 3 columns to the right; the new columns are inserted after ary[0].
                            for (i=6; i>=4; i--) ary[i]=ary[i-3];
                            // First column used to contain up to 3 optional match fields, separated by a pipe ('|').
                            // We hereby move them to the new 2nd through 4th columns so that all match strings are able to contain pipe characters as part of regular expressions.
                            ary0 = ary[0].concat("|||").split("\\|",50);
                            for (i=0; i<=3; i++) ary[i]=ary0[i];
                        }
                        tableModel.addRow(new Object[]{r, ary[0], ary[1], ary[2], ary[3], ary[4], ary[5], ary[6]});
                        r++;
                    }
                    in.close();
                    stringTable.setModel(tableModel);
                    this.setTitle(Main.AppName + ": " + strPatternFile);
                } catch (IOException ex) {
                    handleException(this, "Error while reading '" + myStartupFile.getAbsolutePath() + "': " + ex.toString(), "miOpenActionPerformed subroutine");
                }
            }
        }
    }

    public void saveGrid() {
        int r, c, rows, columns;
        
        //Ensure no sorting or filtering is in place:
        ETableColumnModel cm;
        cm = (ETableColumnModel) stringTable.getColumnModel();
        cm.clearSortedColumns();
        stringTable.unsetQuickFilter();

        File myProgramDir = new File(System.getProperty("user.home") + System.getProperty("file.separator") + ".CustomQIF");
        if (!myProgramDir.exists()) {
            myProgramDir.mkdirs();
        }
        if (myProgramDir.exists()) {
            DefaultTableModel tableModel = (DefaultTableModel) stringTable.getModel();
            rows = tableModel.getRowCount();
            columns = tableModel.getColumnCount();
            File myStartupFile = new File(myProgramDir, strPatternFile + ".Patterns");
            try {
                BufferedWriter out = new BufferedWriter(new FileWriter(myStartupFile));
                for (r = 0; r < rows; r++) {
                    for (c = 1; c < columns; c++) {
                        if (tableModel.getValueAt(r, c) != null) {
                            out.write(tableModel.getValueAt(r, c).toString());
                        }
                        if (c < (columns - 1)) {
                            out.write("\t");
                        }
                    }
                    out.write("\n");
                }
                out.close();
                this.setTitle(Main.AppName + ": " + strPatternFile);
            } catch (IOException ex) {
                handleException(this, "Error while writing '" + myStartupFile.getAbsolutePath() + "': " + ex.toString(), "miSaveActionPerformed subroutine");
            }
        } else {
            handleException(this, "Unable to create directory '" + myProgramDir.getAbsolutePath() + "'", "miSaveActionPerformed subroutine");
        }
    }

    /** Sets line numbers in the grid corresponding to the row numbers **/
    public void numberGrid() {
        int r, rows;
        rows = stringTable.getRowCount();
        for (r = 0; r < rows; r++) {
            stringTable.setValueAt(r+1, r, colRow);
        }
    }

    private void doTheCloseThing() {
        int selection = JOptionPane.showConfirmDialog(
                null,
                "Are you sure you want to quit without saving the patterns?", Main.AppName,
                JOptionPane.YES_NO_CANCEL_OPTION,
                JOptionPane.WARNING_MESSAGE);
        if (selection == JOptionPane.YES_OPTION) {
//            List keys = stringTable.getRowSorter().getSortKeys();
//            List oldKeys = keys;
//            keys.clear();
//            RowSorter.SortKey sk = new RowSorter(0, "ASCENDING");
//            keys.add(RowSorter.SortKey [0, "ASCENDING"]));

            // auto save grid
//            saveGrid();
            saveState();
            dispose();      // Closes the frame
            System.exit(0); // Terminates the application
        }
        // If the user chose "No" or "Cancel" we do nothing
    }

    /** Make window position, selected filenames, the last loaded pattern file and other local configuration data persistent **/
    private void saveState() {
        File myProgramDir = new File(System.getProperty("user.home") + System.getProperty("file.separator") + ".CustomQIF");
        if (!myProgramDir.exists()) {
            myProgramDir.mkdirs();
        }
        if (myProgramDir.exists()) {
            Properties prop = new Properties();
            OutputStream output = null;
            try {
                FileInputStream input = new FileInputStream(myProgramDir.getAbsolutePath() + System.getProperty("file.separator") + "State");
                prop.load(input); // Ensures properties not explicitly handled below are still saved back to the file
            } catch (IOException ioei) {
                // No problem
            }
            try {
                output = new FileOutputStream(myProgramDir.getAbsolutePath() + System.getProperty("file.separator") + "State");
                prop.setProperty("InputFile_" + System.getProperty("os.name").replace(' ', '_'), ctlInputFile.getText());
                prop.setProperty("OutputFile_" + System.getProperty("os.name").replace(' ', '_'), ctlOutputFile.getText());
                prop.setProperty("NarrationOnlyPatterns", strNarrationPatterns);
                prop.setProperty("PatternFile", strPatternFile);
                blnReversedTransactions = miReversedTransactions.getState();
                prop.setProperty("ReversedTransactions", blnReversedTransactions.toString());
                blnCaseSensitive = miCaseSensitive.getState();
                prop.setProperty("CaseSensitive", blnCaseSensitive.toString());
                prop.setProperty("Geometry",
                        String.valueOf(this.getLocation().x) + "," +
                        String.valueOf(this.getLocation().y) + "," +
                        String.valueOf(this.getSize().width) + "," +
                        String.valueOf(this.getSize().height));
                prop.store(output, null);
            } catch (IOException ioex) {
                handleException(this, "Error while writing '" + output.toString() + "': " + ioex.toString(), "saveState subroutine");
            } finally {
                if (output != null) {
                    try {
                        output.close();
                    } catch (IOException e) {
                        handleException(this, "Error while closing '" + output.toString() + "': " + e.toString(), "saveState subroutine");
                    }
                }
            }
        } else {
            handleException(this, "Unable to create directory '" + myProgramDir.getAbsolutePath() + "'", "saveState subroutine");
        }
    }

    /** Load window position, selected filenames, the last loaded pattern file and other local configuration data from saved state **/
    private void loadState() {
        String strKey;
        String strValue;
        String aryGeom[];

        // Set defaults for when values are not set in State file, or there is not yet a State file
        blnReversedTransactions = false;
        blnCaseSensitive = false;
        ctlInputFile.setText(System.getProperty("user.home") + System.getProperty("file.separator") + "inputfile.qif");
        ctlOutputFile.setText(System.getProperty("user.home") + System.getProperty("file.separator") + "outputfile.qif");

        // First see if the .CustomQIF directory exists and create it if not
        File myProgramDir = new File(System.getProperty("user.home") + System.getProperty("file.separator") + ".CustomQIF");
        FileInputStream input = null;
        if (!myProgramDir.mkdirs()) {
            File myStateFile = new File(myProgramDir, "State");
            if (myStateFile.exists()) {
                Properties prop = new Properties();
                try {
                    input = new FileInputStream(myProgramDir.getAbsolutePath() + System.getProperty("file.separator") + "State");
                    prop.load(input);
                } catch (IOException ioei) {
                    // No problem
                }
                strKey = "InputFile_" + System.getProperty("os.name").replace(' ', '_');
                strValue = prop.getProperty(strKey);
                if (strValue != null) {
                    ctlInputFile.setText(strValue);
                }
                strValue = prop.getProperty("OutputFile_" + System.getProperty("os.name").replace(' ', '_'));
                if (strValue != null) {
                    ctlOutputFile.setText(strValue);
                }
                strPatternFile = prop.getProperty("PatternFile", "Untitled");
                strValue = prop.getProperty("Geometry");
                aryGeom = strValue.concat(",,,").split(",");
                int intX = Integer.valueOf(aryGeom[0]);
                if (intX < 0) {
                    intX = this.getLocation().x;
                }
                int intY = Integer.valueOf(aryGeom[1]);
                if (intY < 0) {
                    intY = this.getLocation().y;
                }
                int intWidth = Integer.valueOf(aryGeom[2]);
                if (intWidth<10) {
                    intWidth=this.getSize().width;
                }
                int intHeight = Integer.valueOf(aryGeom[3]);
                if (intHeight<10) {
                    intHeight=this.getSize().height;
                }
                this.setLocation(intX, intY);
                this.setSize(intWidth, intHeight);
                strNarrationPatterns = nvl(prop.getProperty("NarrationOnlyPatterns"));
                tabStrToArray();
                blnReversedTransactions = nvl(prop.getProperty("ReversedTransactions")).equals("true");
                miReversedTransactions.setSelected(blnReversedTransactions);
                blnCaseSensitive = nvl(prop.getProperty("CaseSensitive")).equals("true");
                miCaseSensitive.setSelected(blnCaseSensitive);
                if (input != null) {
                    try {
                        input.close();
                    } catch (IOException ex) {
                        handleException(this, "Error while closing '" + myStateFile.getAbsolutePath() + "': " + ex.toString(), "miOpenActionPerformed subroutine");
                    }
                }
            }
        }
    }

    private void openFile(String string) {
        FileDialog dlg = new FileDialog(this);
        if (ctlInputFile.getText().contains(System.getProperty("file.separator"))) {
            dlg.setFile(ctlInputFile.getText().substring(ctlInputFile.getText().lastIndexOf(System.getProperty("file.separator")) + 1));
            dlg.setDirectory(ctlInputFile.getText().substring(0, ctlInputFile.getText().lastIndexOf(System.getProperty("file.separator"))));
        } else {
            dlg.setFile(ctlInputFile.getText());
            dlg.setDirectory("");
        }
        if (string.matches(".*Input.*")) {
            dlg.setMode(FileDialog.LOAD);
        } else {
            dlg.setMode(FileDialog.SAVE);
        }
        dlg.setVisible(true);
        if (dlg.getFile() != null) {
            if (string.matches(".*Input.*")) {
                String infile = dlg.getDirectory() + dlg.getFile();
                ctlInputFile.setText(infile);
                String outfile = infile.replaceAll("[.][Qq][Ii][Ff]", "_mod.qif");
                if (!infile.equalsIgnoreCase(outfile)) {
                    ctlOutputFile.setText(outfile);
                }
            } else {
                ctlOutputFile.setText(dlg.getDirectory() + dlg.getFile());
            }
        }
    }

    private boolean matchesArrayElement(String strToMatch, String aryToSearch[]) {
        int i = 0;
        String strFromArray;
        boolean matchExists = false;
        while (!matchExists && i<aryToSearch.length) {
            strFromArray = aryToSearch[i].replaceAll("[(]", "\\[\\(\\]");
            strFromArray = strFromArray.replaceAll("[)]", "\\[\\)\\]");
            if (strToMatch.matches(strFromArray)) {
                matchExists = true;
            }
            i++;
        }
        return matchExists;
    }

    private String combineNarrations() {
        String strLine, DD, MM, YYYY;
        File temp;
        intElements = 0;
        intElement = 0;
        intType = 0;
        strHeader = "";
        boolean blnDateChecked = false;
        boolean blnDelimiterFound = false;
        String StrMElement;

        try {
            temp = File.createTempFile("CustomQIF", ".tmp");
        } catch (IOException e) {
            handleException(this, "Unable to create intermediate file.", "combineNarrations Function");
            return null;
        }
        temp.deleteOnExit();

        try {
            BufferedReader in1 = new BufferedReader(new FileReader(ctlInputFile.getText()));
            in1.readLine();
            while ((strLine = in1.readLine()) != null) {
                // Handle ^ transaction delimiter either on separate line or at end of a line
                if (strLine.matches("^D[0-9].*") && !blnDateChecked) {
                    if (strLine.matches("^D[0-9]{8}$")) {
                        blnReformatDate = false;
                    } else if (strLine.matches("^D[0-9]{2}/[0-9]{2}/[0-9]{4}$")) {
                        blnReformatDate = true;
                        if (strLine.substring(1, 3).compareTo("12") > 0) {
                            // If "month" > december, it must be "day"
                            blnDDMM = true;
                        }
                        if (strLine.substring(4, 6).compareTo("12") > 0) {
                            blnDDMM = false;
                        }
                    }
                }
                if (strLine.endsWith("^")) {
                    intElements++;
                }
            }
            in1.close();
        } catch (IOException f) {
            handleException(this, "Unable to read input file \"" + ctlInputFile.getText() + "\" to count the elements.", "combineNarrations Function");
            return null;
        }

        aryQIF = new String[intElements][strTypes.length()];
        aryKeep = new Boolean[intElements];

        try {
            BufferedReader in2 = new BufferedReader(new FileReader(ctlInputFile.getText()));
            strLine = in2.readLine();
            strHeader = strLine;
            while ((strLine = in2.readLine()) != null) {
                // Handle ^ transaction delimiter either on separate line or at end of a line
                if (!strLine.equals("^") && !strLine.isEmpty()) {
                    if (strLine.endsWith("^")) {
                        blnDelimiterFound = true;
                        strLine = strLine.substring(0, strLine.length() - 1);
                    }
                    intType = strTypes.indexOf(strLine.charAt(0));
                    if (intType >= 0) {
                        try {
                            if (intType == D && blnReformatDate) {
                                if (blnDDMM) {
                                    DD = strLine.substring(1,3);
                                    MM = strLine.substring(4,6);
                                } else {
                                    DD = strLine.substring(4,6);
                                    MM = strLine.substring(1,3);
                                }
                                YYYY = strLine.substring(7,11);
                                strLine = strLine.substring(0,1).concat(YYYY).concat(MM).concat(DD);
                            }
                            aryQIF[intElement][intType] = strLine.substring(1);
                        } catch (ArrayIndexOutOfBoundsException ae) {
                            handleException(this, "Error while storing array element: " + ae.toString(), "combineNarrations function");
                        }
                    }
                    if (blnDelimiterFound) {
                        strLine = "^";
                        blnDelimiterFound = false;
                    }
                }
                if (strLine.equals("^")) {
                    aryKeep[intElement] = true;
                    // Fix missing L tags; TODO: Make this list dynamic so user can configure.  Save it in State file.
                    if (aryQIF[intElement][L] == null) {
                        StrMElement = aryQIF[intElement][M].toUpperCase();
                        if (aryQIF[intElement][N] != null
                                || StrMElement.contains("PERSONAL CHEQUE")) {
                            aryQIF[intElement][L] = "CHECK";
                        } else if ((StrMElement.indexOf("CREDIT ") == 0 &&
                                   !StrMElement.startsWith("JOURNAL")) ||
                                (  StrMElement.contains("DEPOSIT")
                                && aryQIF[intElement][T].charAt(0) != '-')) {
                            aryQIF[intElement][L] = "DEP";
                        } else if (StrMElement.contains("PERIODIC PAY")
                                && aryQIF[intElement][T].charAt(0) == '-') {
                            aryQIF[intElement][L] = "REPEATPMT";
                        } else if (StrMElement.contains("T'FER")
                                || StrMElement.contains("TFR")
                                || StrMElement.contains("DEBIT TRANSFER")) {
                            aryQIF[intElement][L] = "XFER";
                        } else if (StrMElement.contains("WITHDRAWAL")) {
                            aryQIF[intElement][L] = "DEBIT";
                        } else if (aryQIF[intElement][T].charAt(0) == '-'
                                || StrMElement.contains("RETAIL PURCHASE")
                                || StrMElement.contains("BPAY")
                                || StrMElement.contains("DIRECT DEBIT")
                                || StrMElement.contains("TRANSACTION FEE")
                                || StrMElement.contains("LOAN INTEREST")
                                || StrMElement.contains("BILL PAYMENT")) {
                            aryQIF[intElement][L] = "PAYMENT";
                        } else if (!aryQIF[intElement][T].equals("0")) {
                            aryQIF[intElement][L] = "DEP";
                        } else if (aryQIF[intElement][T].equals("0")) {
                            aryQIF[intElement][L] = "INFO";
                        }
                    }
                    intElement++;
                }
            }
            in2.close();
        } catch (IOException g) {
            handleException(this, "Unable to read input file \"" + ctlInputFile.getText() + "\".", "combineNarrations Function");
            return null;
        }

        if (intElement > 0) {
            blnReversedTransactions = miReversedTransactions.getState();
            if (blnReversedTransactions) {
                reverseItems();
            }
            try {
                BufferedWriter out = new BufferedWriter(new FileWriter(temp));
                out.write(strHeader);
                for (int i = 0; i < intElements; i++) {
                    if (aryKeep[i]) {
                        // See if there is a narration to add from one transaction below
                        if ((i + 1) < intElements) {
                            if (aryQIF[i][M].equals("LOAN INTEREST")) {
                                // These ones (almost?) always have a 2nd narration of a known pattern after them, either immediately or a bit later:
                                boolean blnLIdone = false;
                                for (int li = 1 ; (i + li < intElements) && (li < 16) && !blnLIdone ; li++) {
                                    if (aryKeep[i + li] && aryQIF[i + li][M].matches("PAYMENT ALTERED .*")) {
                                        aryQIF[i][M] = aryQIF[i][M] + " / " + aryQIF[i + li][M];
                                        aryKeep[i + li] = false;
                                        blnLIdone = true;
                                    }
                                }
                            } else if (!aryQIF[i][T].equals("0") && aryQIF[i + 1][T].equals("0") && !matchesArrayElement(aryQIF[i + 1][M], aryNarrationPatterns)) {
                                aryQIF[i][M] = aryQIF[i][M] + " / " + aryQIF[i + 1][M];
                                aryKeep[i + 1] = false;
                                // Sometimes there will be additional narrations below
                                if ((i + 2) < intElements) {
                                    // Only if same date as first extra narration
                                    try {
                                        if (aryQIF[i + 2][D].equals(aryQIF[i + 1][D]) && aryQIF[i + 2][T].equals("0") && !matchesArrayElement(aryQIF[i + 2][M], aryNarrationPatterns)) {
                                            aryQIF[i][M] = aryQIF[i][M] + " / " + aryQIF[i + 2][M];
                                            aryKeep[i + 2] = false;
                                            if ((i + 3) < intElements) {
                                                // Only if same date as first extra narration
                                                if (aryQIF[i + 3][D].equals(aryQIF[i + 1][D]) && aryQIF[i + 3][T].equals("0") && !matchesArrayElement(aryQIF[i + 3][M], aryNarrationPatterns)) {
                                                    aryQIF[i][M] = aryQIF[i][M] + " / " + aryQIF[i + 3][M];
                                                    aryKeep[i + 3] = false;
                                                }
                                            }
                                        }
                                    } catch (NullPointerException npe) {
                                        handleException(this, "Error while examining adjacent rows", "combineNarrations Function");
                                    }
                                }
                            }
                        }
                        for (int j = 0; j < strTypes.length(); j++) {
                            if (aryQIF[i][j] != null) {
                                out.write(strTypes.charAt(j) + aryQIF[i][j] + "\n");
                            }
                        }
                        out.write("^\n");
                    }
                }
                out.close();
            } catch (IOException ex) {
                handleException(this, "Error while writing intermediate file '" + temp.getAbsolutePath() + "': " + ex.toString(), "combineNarrations function");
            }

        } else {
            handleException(this, "Input file \"" + ctlInputFile.getText() + "\" is either not a .QIF file or is empty..", "combineNarrations Function");
            return null;
        }

        return temp.getAbsolutePath();
    }

    public SortedComboBoxModel getAccountList() {
        int r, rows;
        SortedComboBoxModel itemList = new SortedComboBoxModel();
        DefaultTableModel tableModel = (DefaultTableModel) stringTable.getModel();
        rows = tableModel.getRowCount();
        
        for (r = 0; r < rows; r++) {
            if (itemList.getIndexOf(tableModel.getValueAt(r, colAccount)) < 0) {
                itemList.addElement(tableModel.getValueAt(r, colAccount));
            }
        }
        return itemList;
    }

    public void replaceRow(int row, String xNarration, String xDate, String xAmount, String xCheque, String xtype, String account, String annotation) {
        stringTable.setValueAt(row, row, colRow);    // Row number column; does not appear in data file
        stringTable.setValueAt(xNarration, row, colNarration);
        stringTable.setValueAt(xDate, row, colXDate);
        stringTable.setValueAt(xAmount, row, colXAmount);
        stringTable.setValueAt(xCheque, row, colCheque);
        stringTable.setValueAt(xtype, row, colXType);
        stringTable.setValueAt(account, row, colAccount);
        stringTable.setValueAt(annotation, row, colAnnotation);
    }
    
    // Reverse the order of the transactions array
    public void reverseItems() {
        String strTemp;
        boolean blnTemp;
        int i = 0, j = aryQIF.length - 1, k;
        while (i < j) {
            for (k = 0; k < strTypes.length(); k++) {
                strTemp = aryQIF[i][k];
                aryQIF[i][k] = aryQIF[j][k];
                aryQIF[j][k] = strTemp;
            }
            blnTemp = aryKeep[i];
            aryKeep[i] = aryKeep[j];
            aryKeep[j] = blnTemp;
            i++;
            j--;
        }
    }
    
    // Return the rectangle definition representing the screen the point (thisX, thisY) is on
    public Rectangle getThisScreen(int thisX, int thisY) {
        Rectangle rect;
        GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();
        GraphicsDevice[] gs = ge.getScreenDevices();
        for (int s = 0; s < gs.length; s++) {   // Each screen
            GraphicsDevice gd = gs[s];
            GraphicsConfiguration[] gc = gd.getConfigurations();
            for (int i=0; i < gc.length; i++) {
                rect = gs[s].getDefaultConfiguration().getBounds();
                if (rect.x <= thisX && thisX < (rect.x + rect.width)
                        && rect.y <= thisY && thisY < (rect.y + rect.height)) {
                    return rect;
                }
            }
        }
        handleException(this, "Can't find where on the display our window is!", "Window Positioning Error");
        return (Rectangle) null;
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    javax.swing.JButton btnExecute;
    javax.swing.JButton btnInputFile;
    javax.swing.JButton btnLearn;
    javax.swing.JButton btnOutputFile;
    javax.swing.JTextField ctlInputFile;
    javax.swing.JTextField ctlOutputFile;
    javax.swing.JMenu jMenu1;
    javax.swing.JScrollPane jScrollPane1;
    javax.swing.JMenuItem jmiEdit;
    javax.swing.JPopupMenu jpmTableContext;
    javax.swing.JMenu mEdit;
    javax.swing.JMenu mFile;
    javax.swing.JMenu mHelp;
    javax.swing.JMenu mOptions;
    javax.swing.JMenuBar mb;
    javax.swing.JMenuItem miAbout;
    javax.swing.JMenuItem miAdd;
    javax.swing.JCheckBoxMenuItem miCaseSensitive;
    javax.swing.JMenuItem miDown;
    javax.swing.JMenuItem miEdit;
    javax.swing.JMenuItem miNarrationOnly;
    javax.swing.JMenuItem miOpen;
    javax.swing.JMenuItem miQuit;
    javax.swing.JMenuItem miRemove;
    javax.swing.JCheckBoxMenuItem miReversedTransactions;
    javax.swing.JMenuItem miSave;
    javax.swing.JMenuItem miSaveAs;
    javax.swing.JMenuItem miUp;
    org.netbeans.swing.etable.ETable stringTable;
    // End of variables declaration//GEN-END:variables
}

